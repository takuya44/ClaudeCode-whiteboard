---
description: 仕様書の包括的な要件を生成する
allowed-tools: Bash, Read, Write, Edit, MultiEdit, Update, WebSearch, WebFetch
---

# 要件生成

機能の包括的な要件を生成：**$ARGUMENTS**

## コンテキスト検証

### ステアリングコンテキスト

- アーキテクチャコンテキスト: @.kiro/steering/structure.md
- 技術的制約: @.kiro/steering/tech.md
- プロダクトコンテキスト: @.kiro/steering/product.md

### 既存の仕様書コンテキスト

- 現在の仕様書ディレクトリ: !`ls -la .kiro/specs/$ARGUMENTS/`
- 現在の要件: @.kiro/specs/$ARGUMENTS/requirements.md
- 仕様書メタデータ: @.kiro/specs/$ARGUMENTS/spec.json

## タスク: 初期要件の生成

機能アイデアに基づいて EARS 形式で初期要件セットを生成し、完全で正確になるまでユーザーと反復して改良します。

このフェーズではコード探索に焦点を当てず、後で設計に変換される要件の作成にのみ集中してください。

### 要件生成ガイドライン

1. **コア機能に焦点**: ユーザーのアイデアから重要な機能から開始
2. **EARS 形式を使用**: すべての受入基準は適切な EARS 構文を使用する必要があります
3. **順次質問なし**: まず初期バージョンを生成し、その後ユーザーフィードバックに基づいて反復
4. **管理可能に保つ**: ユーザーレビューを通じて拡張できる堅実な基盤を作成

### 1. EARS 形式要件

**EARS（Easy Approach to Requirements Syntax）**は受入基準の必須形式です：

**主要な EARS パターン：**

- **WHEN** [イベント/条件] **THEN** [システム] **SHALL** [応答]
- **IF** [前提条件/状態] **THEN** [システム] **SHALL** [応答]
- **WHILE** [継続条件] **THE SYSTEM SHALL** [継続的動作]
- **WHERE** [場所/コンテキスト] **THE SYSTEM SHALL** [コンテキスト動作]

**組み合わせパターン：**

- **WHEN** [イベント] **AND** [追加条件] **THEN** [システム] **SHALL** [応答]
- **IF** [条件] **AND** [追加条件] **THEN** [システム] **SHALL** [応答]

### 2. 要件階層と粒度

**明確な階層で要件を構造化：**

```
# 要件文書
├── はじめに（機能概要）
├── 要件
│   ├── 要件1（主要機能領域）
│   │   ├── ユーザーストーリー（高レベルニーズ）
│   │   └── 受入基準（詳細なEARS）
│   │       ├── ハッピーパスシナリオ
│   │       ├── エッジケースとエラー条件
│   │       ├── ユーザーエクスペリエンス考慮事項
│   │       └── 技術的制約
│   ├── 要件2（次の機能領域）
│   └── ...
```

**粒度ガイドライン：**

- **高レベル要件**: 機能アイデアからの主要機能領域
- **ユーザーストーリー**: 各要件領域内の具体的なユーザーニーズ
- **受入基準**: EARS 形式を使用したテスト可能な条件

### 3. 要件文書構造

spec.json で指定された言語で requirements.md を生成（`@.kiro/specs/$ARGUMENTS/spec.json`の"language"フィールドを確認）：

```markdown
# 要件文書

## はじめに

[機能とそのビジネス価値を要約した明確な導入部]

## 要件

### 要件 1：[主要機能領域]

**ユーザーストーリー：** [役割]として、[機能]が欲しい、[利益]のために

#### 受入基準

このセクションは EARS 要件を含む必要があります

1. WHEN [イベント] THEN [システム] SHALL [応答]
2. IF [前提条件] THEN [システム] SHALL [応答]
3. WHILE [継続条件] THE SYSTEM SHALL [継続的動作]
4. WHERE [場所/コンテキスト] THE SYSTEM SHALL [コンテキスト動作]

### 要件 2：[次の主要機能領域]

**ユーザーストーリー：** [役割]として、[機能]が欲しい、[利益]のために

1. WHEN [イベント] THEN [システム] SHALL [応答]
2. WHEN [イベント] AND [条件] THEN [システム] SHALL [応答]

### 要件 3：[追加の主要領域]

[すべての主要機能領域について同様のパターンを継続]
```

### 4. メタデータの更新

spec.json を以下で更新：

```json
{
  "phase": "requirements-generated",
  "approvals": {
    "requirements": {
      "generated": true,
      "approved": false
    }
  },
  "updated_at": "現在のタイムスタンプ"
}
```

### 5. 文書生成のみ

要件文書の内容のみを生成してください。実際の文書ファイルにはレビューや承認の指示を含めないでください。

---

## インタラクティブ承認利用可能（文書には含まれません）

以下は Claude Code の会話のみ用 - 生成された文書用ではありません：

### 次フェーズではインタラクティブ承認を使用

requirements.md 生成後、次フェーズ（`/spec-design $ARGUMENTS`）はインタラクティブ承認を使用します：

**次のインタラクションは以下になります**：

```
/spec-design 機能名
# → "requirements.mdをレビューしましたか？ [y/N]"
# → 'y'の場合：自動承認 + 設計生成
# → 'N'の場合：まずレビューを要求して停止
```

### インタラクティブ承認の利点

1. **合理化されたワークフロー**: 手動での spec.json 編集不要
2. **レビュー実施**: レビューの人間による確認が依然として必要
3. **即座の進行**: 承認されたフェーズは自動的に進行
4. **安全性維持**: 'N'応答は適切なレビューのため実行を停止

### レビューチェックリスト（ユーザー参照用）：

- [ ] 要件が明確で完全である
- [ ] ユーザーストーリーが必要な機能をすべてカバーしている
- [ ] 受入基準がテスト可能である
- [ ] 要件がプロジェクト目標と整合している

### 従来の手動承認も引き続き利用可能

必要に応じて、`.kiro/specs/$ARGUMENTS/spec.json`を更新して手動承認することもできます：

```json
{
  "approvals": {
    "requirements": {
      "generated": true,
      "approved": true
    }
  },
  "phase": "requirements-approved"
}
```

**推奨**: より良いユーザーエクスペリエンスのため、`/spec-design $ARGUMENTS`でインタラクティブ承認を使用してください。

## 手順

1. **言語のため spec.json を確認** - メタデータで指定された言語を使用
2. **機能アイデアに基づいて初期要件を生成** 最初に順次質問をしないで
3. **EARS 形式を適用** - すべての受入基準に適切な EARS 構文パターンを使用
4. **コア機能に焦点** - 重要な機能とユーザーワークフローから開始
5. **明確に構造化** - 関連機能を論理的な要件領域にグループ化
6. **要件をテスト可能にする** - 各受入基準は検証可能である必要があります
7. **完了時に追跡メタデータを更新**

機能アイデアからのコア機能に焦点を当て、設計フェーズのための堅実な基盤を提供する要件を生成してください。
