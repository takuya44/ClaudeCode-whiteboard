---
description: プロジェクト状態に基づいてKiroステアリング文書をインテリジェントに作成または更新する
allowed-tools: Bash, Read, Write, Edit, MultiEdit, Glob, Grep, LS
---

# Kiro ステアリング管理

仕様駆動開発のため正確なプロジェクト知識を維持するため、`.kiro/steering/`内のステアリング文書をインテリジェントに作成または更新します。このコマンドは既存文書を検出し、適切に処理します。

## 既存ファイルチェック

### 現在のステアリング文書ステータス

- プロダクト概要：!`[ -f ".kiro/steering/product.md" ] && echo "✅ 存在 - カスタムコンテンツを保持して更新されます" || echo "📝 見つかりません - 作成されます"`
- テクノロジースタック：!`[ -f ".kiro/steering/tech.md" ] && echo "✅ 存在 - カスタムコンテンツを保持して更新されます" || echo "📝 見つかりません - 作成されます"`
- プロジェクト構造：!`[ -f ".kiro/steering/structure.md" ] && echo "✅ 存在 - カスタムコンテンツを保持して更新されます" || echo "📝 見つかりません - 作成されます"`
- カスタムステアリングファイル：!`if [ -d ".kiro/steering" ]; then count=$(find .kiro/steering -maxdepth 1 -type f -name '*.md' ! -name 'product.md' ! -name 'tech.md' ! -name 'structure.md' | grep -c .); if [ "$count" -gt 0 ]; then echo "🔧 $count個のカスタムファイルが見つかりました - 保持されます"; else echo "📋 カスタムファイルなし"; fi; else echo "📋 ステアリングディレクトリはまだありません"; fi`

## プロジェクト分析

### 現在のプロジェクト状態

- プロジェクトファイル：!`find . -path ./node_modules -prune -o -path ./.git -prune -o -path ./dist -prune -o -type f \( -name "*.py" -o -name "*.js" -o -name "*.ts" -o -name "*.jsx" -o -name "*.tsx" -o -name "*.java" -o -name "*.go" -o -name "*.rs" \) -print 2>/dev/null || echo "ソースファイルが見つかりません"`
- 設定ファイル：!`find . -maxdepth 3 \( -name "package.json" -o -name "requirements.txt" -o -name "pom.xml" -o -name "Cargo.toml" -o -name "go.mod" -o -name "pyproject.toml" -o -name "tsconfig.json" \) 2>/dev/null || echo "設定ファイルが見つかりません"`
- ドキュメント：!`find . -maxdepth 3 -path ./node_modules -prune -o -path ./.git -prune -o -path ./.kiro -prune -o \( -name "README*" -o -name "CHANGELOG*" -o -name "LICENSE*" -o -name "*.md" \) -print 2>/dev/null || echo "ドキュメントファイルが見つかりません"`

### 最近の変更（更新の場合）

- 最後のステアリング更新：!`git log -1 --oneline -- .kiro/steering/ 2>/dev/null || echo "前回のステアリングコミットなし"`
- 最後のステアリング更新以降のコミット：!`LAST_COMMIT=$(git log -1 --format=%H -- .kiro/steering/ 2>/dev/null); if [ -n "$LAST_COMMIT" ]; then git log --oneline ${LAST_COMMIT}..HEAD --max-count=20 2>/dev/null || echo "gitリポジトリではありません"; else echo "前回のステアリング更新が見つかりません"; fi`
- ワーキングツリーステータス：!`git status --porcelain 2>/dev/null || echo "gitリポジトリではありません"`

### 既存ドキュメント

- メイン README：@README.md
- パッケージ設定：@package.json
- Python 要件：@requirements.txt
- TypeScript 設定：@tsconfig.json
- プロジェクトドキュメント：@docs/

## スマート更新戦略

上記の既存ファイルチェックに基づいて、このコマンドは以下を実行します：

### 新規ファイル（"📝 見つかりません"と表示）の場合：

プロジェクトのすべての側面をカバーする包括的な初期コンテンツを生成。

### 既存ファイル（"✅ 存在"と表示）の場合：

1. **ユーザーカスタマイゼーションを保持** - 手動編集やカスタムセクション
2. **事実情報を更新** - 依存関係、ファイル構造、コマンド
3. **新しいセクションを追加** - 重要な新機能が存在する場合のみ
4. **廃止予定コンテンツをマーク** - 削除ではなく
5. **フォーマットを維持** - 既存スタイルとの一貫性を保つ

## コアステアリングファイルの包含モード

3 つのコアステアリングファイル（product.md、tech.md、structure.md）は**常に含まれる**設計 - 一貫したプロジェクトコンテキストを提供するためすべての AI インタラクションで読み込まれます。

### 包含モードの理解

- **常に含まれる（コアファイルのデフォルト）**：すべてのインタラクションで読み込まれる - 一貫したプロジェクト知識を確保
- **条件付き**：一致するファイルパターンで作業する場合のみ読み込まれる（主にカスタムステアリング用）
- **手動**：@filename 構文でオンデマンド参照（専門的なコンテキスト用）

### コアファイル戦略

- `product.md`：常時 - すべての開発決定にビジネスコンテキストが必要
- `tech.md`：常時 - 技術的制約がすべてのコード生成に影響
- `structure.md`：常時 - アーキテクチャ決定がすべてのファイル構成に影響

## タスク：ステアリング文書の作成または更新

### 1. プロダクト概要（`product.md`）

#### 新規ファイルの場合：

以下を含む包括的なプロダクト概要を生成：

- **プロダクト概要**：プロダクトが何であるかの簡潔な説明
- **コア機能**：主要機能の箇条書きリスト
- **対象ユースケース**：プロダクトが対処する具体的なシナリオ
- **主要価値提案**：独自の利点と差別化要因

#### 既存ファイルの場合：

以下がある場合のみ更新：

- **新機能**：プロダクトに追加された機能
- **削除された機能**：廃止予定の機能
- **変更されたユースケース**：対象オーディエンス
- **更新された価値提案**：利点

### 2. テクノロジースタック（`tech.md`）

#### 新規ファイルの場合：

完全な技術環境を文書化：

- **アーキテクチャ**：高レベルシステム設計
- **フロントエンド**：フレームワーク、ライブラリ、ビルドツール（該当する場合）
- **バックエンド**：言語、フレームワーク、サーバー技術（該当する場合）
- **開発環境**：必要なツールとセットアップ
- **共通コマンド**：頻繁に使用される開発コマンド
- **環境変数**：主要な設定変数
- **ポート設定**：サービスで使用される標準ポート

#### 既存ファイルの場合：

以下の変更をチェック：

- **新しい依存関係**：パッケージマネージャーを介して追加
- **削除されたライブラリ**：フレームワーク
- **バージョンアップグレード**：主要依存関係
- **新しい開発ツール**：ビルドプロセス
- **変更された環境変数**：設定
- **変更されたポート割り当て**：サービスアーキテクチャ

### 3. プロジェクト構造（`structure.md`）

#### 新規ファイルの場合：

コードベース構成を概説：

- **ルートディレクトリ構成**：説明付きトップレベル構造
- **サブディレクトリ構造**：主要ディレクトリの詳細内訳
- **コード構成パターン**：コードの構造化方法
- **ファイル命名規則**：ファイルとディレクトリの命名標準
- **インポート構成**：インポート/依存関係の整理方法
- **主要アーキテクチャ原則**：コア設計決定とパターン

#### 既存ファイルの場合：

以下の変更を確認：

- **新しいディレクトリ**：大規模な再編成
- **変更されたファイル構成**：パターン
- **新しいまたは変更された命名規則**
- **更新されたアーキテクチャパターン**：原則
- **リファクタリングされたコード構造**：モジュール境界

### 4. カスタムステアリングファイル

カスタムステアリングファイルが存在する場合：

- **保持する** - 特に古くない限り変更しない
- **関連性をチェック** - 削除された機能を参照している場合は注記
- **新しいカスタムファイルを提案** - 新しい専門分野が出現した場合

## 手順

1. **`.kiro/steering/`ディレクトリを作成**（存在しない場合）
2. **既存ファイルをチェック**して作成 vs 更新モードを決定
3. **ネイティブツールを使用してコードベースを分析**（Glob、Grep、LS）
4. **新規ファイルの場合**：包括的な初期ドキュメントを生成
5. **既存ファイルの場合**：
   - まず現在のコンテンツを読み取り
   - ユーザーカスタマイゼーションとコメントを保持
   - 事実/技術情報のみを更新
   - 既存の構造とスタイルを維持
6. **明確なマークダウン形式を使用**：適切なヘッダーとセクション
7. **理解に役立つ具体的な例を含める**
8. **仮定より事実に焦点**：存在するものを文書化
9. **仕様駆動開発原則に従う**

## 重要な原則

### セキュリティガイドライン

- **機密データを含めない**：API キー、パスワード、データベース資格情報、個人情報なし
- **コミット前にレビュー**：バージョン管理前にステアリングコンテンツを常にレビュー
- **チーム共有の考慮**：ステアリングファイルはすべてのプロジェクト協力者と共有されることを忘れずに

### コンテンツ品質ガイドライン

- **単一ドメイン焦点**：各ステアリングファイルは 1 つの特定領域をカバーする必要があります
- **明確で説明的なコンテンツ**：決定の具体的な例と根拠を提供
- **定期的なメンテナンス**：プロジェクトの主要変更後にステアリングファイルをレビューし更新
- **実行可能なガイダンス**：抽象的な原則ではなく、具体的で実装可能なガイドラインを記述

### 保持戦略

- **ユーザーセクション**：標準テンプレートにないセクションは保持する必要があります
- **カスタム例**：ユーザーが追加した例は維持する必要があります
- **コメント**：インラインコメントやノートは保持する必要があります
- **フォーマット設定**：既存のマークダウンスタイルの選択を尊重

### 更新哲学

- **デフォルトで追加的**：置き換えではなく新しい情報を追加
- **廃止予定をマーク**：取り消し線や[DEPRECATED]タグを使用
- **重要な変更に日付を付ける**：主要変更の更新タイムスタンプを追加
- **変更を説明**：なぜ何かが更新されたかの簡潔なノート

目標は、ユーザーカスタマイゼーションを尊重しながら最新の状態を保つ生きた文書を維持し、ユーザーが作業を失うことを心配せずに効果的な仕様駆動開発をサポートすることです。
