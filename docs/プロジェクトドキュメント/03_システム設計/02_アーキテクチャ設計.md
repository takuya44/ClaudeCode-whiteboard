# アーキテクチャ設計

## 1. アーキテクチャ概要

### 1.1 アーキテクチャパターン
本システムは**3層アーキテクチャ**を基盤とし、**イベント駆動アーキテクチャ**の要素を組み合わせたハイブリッド構成を採用します。

### 1.2 設計原則
- **SOLID原則**: 単一責任、開放閉鎖、リスコフ置換、インターフェース分離、依存関係逆転
- **DRY原則**: Don't Repeat Yourself
- **YAGNI原則**: You Aren't Gonna Need It
- **関心の分離**: レイヤー間の責任明確化

## 2. レイヤーアーキテクチャ

### 2.1 プレゼンテーション層（Presentation Layer）

#### 責任範囲
- ユーザーインターフェースの表示
- ユーザー入力の受付・検証
- アプリケーション層との連携

#### 構成要素（実装済み）
```typescript
// Vue.js 3.3.8 + TypeScript 5.2.0 構造
frontend/src/
├── components/
│   ├── common/           # 共通コンポーネント
│   ├── whiteboard/       # ホワイトボード描画・編集
│   ├── auth/            # 認証フォーム
│   └── layout/          # アプリケーションレイアウト
├── composables/        # Composition API ロジック
├── stores/             # Pinia 2.1.7 状態管理
├── utils/              # ユーティリティ関数
├── services/           # Axios API通信
├── types/              # TypeScript型定義
└── views/              # ページコンポーネント
```

#### 主要パターン
- **Composition API Pattern**: ロジックと表示の分離
- **Composables Pattern**: 状態ロジックの再利用
- **Store Pattern**: グローバル状態の管理（Pinia）

### 2.2 アプリケーション層（Application Layer）

#### 責任範囲
- ビジネスロジックの実行
- ドメインサービスの調整
- トランザクション管理

#### 構成要素（実装済み）
```python
# FastAPI 0.104.1 + SQLAlchemy 2.0.23 構造
backend/app/
├── api/               # FastAPI APIルーター
│   ├── auth.py        # 認証エンドポイント
│   ├── users.py       # ユーザー管理
│   └── whiteboards.py # ホワイトボード操作
├── models/            # SQLAlchemy データモデル
│   ├── user.py        # ユーザーモデル
│   ├── whiteboard.py  # ホワイトボードモデル
│   └── drawing_element.py # 描画要素モデル
├── schemas/           # Pydantic スキーマ
├── services/          # ビジネスロジック
├── websocket/         # WebSocket接続管理
├── core/              # 設定・依存性注入
└── utils/             # ユーティリティ
```

#### 主要パターン
- **Service Layer Pattern**: ビジネスロジックの集約
- **Command Pattern**: 操作の抽象化
- **Observer Pattern**: イベント通知

### 2.3 データアクセス層（Data Access Layer）

#### 責任範囲
- データの永続化・取得
- データベースとの通信
- キャッシュ管理

#### 構成要素
```python
# データアクセス構造
app/
├── repositories/       # データリポジトリ
├── models/            # SQLAlchemyモデル
├── migrations/        # Alembicマイグレーション
└── cache/             # キャッシュ管理
```

#### 主要パターン
- **Repository Pattern**: データアクセスの抽象化
- **Unit of Work Pattern**: トランザクション管理
- **Data Mapper Pattern**: オブジェクト-リレーショナルマッピング

## 3. リアルタイム通信アーキテクチャ

### 3.1 WebSocket通信設計

#### 接続管理
```typescript
interface ConnectionManager {
  // クライアント接続管理
  connect(userId: string, socketId: string): void;
  disconnect(socketId: string): void;
  
  // ルーム管理
  joinRoom(socketId: string, whiteboardId: string): void;
  leaveRoom(socketId: string, whiteboardId: string): void;
  
  // メッセージブロードキャスト
  broadcast(room: string, event: string, data: any): void;
}
```

#### イベント設計
```python
# WebSocketメッセージ型定義
from typing import Dict, Any
from pydantic import BaseModel

class WebSocketMessage(BaseModel):
    type: str
    data: Dict[str, Any]

# クライアント→サーバーメッセージ
class DrawingStartMessage(BaseModel):
    type: str = "drawing:start"
    data: DrawingStartData

class DrawingUpdateMessage(BaseModel):
    type: str = "drawing:update" 
    data: DrawingUpdateData

# サーバー→クライアントメッセージ
class DrawingBroadcastMessage(BaseModel):
    type: str = "drawing:broadcast"
    data: DrawingData
    
class UserJoinedMessage(BaseModel):
    type: str = "user:joined"
    data: UserData
```
```

### 3.2 競合制御アーキテクチャ

#### 楽観的ロック
```python
from dataclasses import dataclass
from datetime import datetime
from typing import Optional

@dataclass
class OptimisticLock:
    version: int
    last_modified: datetime
    modified_by: str

class ConflictResolver:
    def resolve(
        self,
        current_version: OptimisticLock,
        incoming_update: ObjectUpdate
    ) -> ConflictResolution:
        if current_version.version != incoming_update.expected_version:
            return self.handle_conflict(current_version, incoming_update)
        return ConflictResolution(success=True, resolved_data=incoming_update.data)
```

## 4. ドメイン駆動設計（DDD）

### 4.1 ドメインモデル

#### Whiteboard Aggregate
```python
from typing import List
from dataclasses import dataclass, field

@dataclass
class Whiteboard:
    id: WhiteboardId
    title: str
    owner_id: UserId
    objects: List[WhiteboardObject] = field(default_factory=list)
    collaborators: List[Collaborator] = field(default_factory=list)

    def add_object(self, obj: WhiteboardObject, user_id: UserId) -> None:
        self._validate_edit_permission(user_id)
        self.objects.append(obj)
        self._publish_event(ObjectAddedEvent(self.id, obj))

    def share_with(self, user_id: UserId, permission: Permission) -> None:
        self._validate_ownership()
        self.collaborators.append(Collaborator(user_id, permission))
        self._publish_event(WhiteboardSharedEvent(self.id, user_id, permission))
```

#### User Aggregate
```python
@dataclass
class User:
    id: UserId
    email: Email
    profile: UserProfile
    permissions: List[Permission] = field(default_factory=list)

    def authenticate(self, password: str) -> AuthenticationResult:
        # 認証ロジック
        pass

    def has_permission(self, resource: Resource, action: Action) -> bool:
        # 認可ロジック
        return any(perm.allows(resource, action) for perm in self.permissions)
```

### 4.2 ドメインサービス

#### コラボレーションサービス
```python
class CollaborationService:
    def __init__(
        self,
        whiteboard_repository: WhiteboardRepository,
        user_repository: UserRepository,
        event_bus: EventBus
    ):
        self.whiteboard_repository = whiteboard_repository
        self.user_repository = user_repository
        self.event_bus = event_bus

    async def join_whiteboard(
        self, 
        user_id: UserId, 
        whiteboard_id: WhiteboardId
    ) -> JoinResult:
        user = await self.user_repository.find_by_id(user_id)
        whiteboard = await self.whiteboard_repository.find_by_id(whiteboard_id)
        
        if not whiteboard.can_user_access(user):
            raise UnauthorizedAccessError()
        
        await self.event_bus.publish(
            UserJoinedWhiteboardEvent(user_id, whiteboard_id)
        )
        
        return JoinResult(whiteboard.get_current_state())
```

## 5. イベント駆動アーキテクチャ

### 5.1 イベントソーシング（部分採用）

#### イベントストア
```typescript
interface EventStore {
  append(streamId: string, events: DomainEvent[]): Promise<void>;
  getEvents(streamId: string, fromVersion?: number): Promise<DomainEvent[]>;
  subscribe(eventType: string, handler: EventHandler): void;
}

// ホワイトボード変更イベント
class WhiteboardObjectAddedEvent implements DomainEvent {
  constructor(
    public readonly aggregateId: string,
    public readonly version: number,
    public readonly timestamp: Date,
    public readonly objectData: ObjectData
  ) {}
}
```

### 5.2 CQRS（コマンド・クエリ責任分離）

#### コマンド側
```typescript
// コマンド
interface AddObjectCommand {
  whiteboardId: string;
  userId: string;
  objectData: ObjectData;
}

// コマンドハンドラー
class AddObjectCommandHandler {
  async handle(command: AddObjectCommand): Promise<void> {
    const whiteboard = await this.repository.getById(command.whiteboardId);
    whiteboard.addObject(command.objectData, command.userId);
    await this.repository.save(whiteboard);
  }
}
```

#### クエリ側
```typescript
// クエリ
interface GetWhiteboardQuery {
  whiteboardId: string;
  userId: string;
}

// クエリハンドラー
class GetWhiteboardQueryHandler {
  async handle(query: GetWhiteboardQuery): Promise<WhiteboardView> {
    // 読み取り専用の最適化されたクエリ
    return await this.readModel.getWhiteboardView(
      query.whiteboardId, 
      query.userId
    );
  }
}
```

## 6. セキュリティアーキテクチャ

### 6.1 認証・認可設計

#### JWT認証
```typescript
interface AuthenticationService {
  authenticate(credentials: Credentials): Promise<AuthResult>;
  refreshToken(refreshToken: string): Promise<TokenPair>;
  validateToken(token: string): Promise<TokenClaims>;
}

interface AuthorizationService {
  authorize(user: User, resource: Resource, action: Action): Promise<boolean>;
  getPermissions(user: User, resource: Resource): Promise<Permission[]>;
}
```

#### RBAC（Role-Based Access Control）
```typescript
enum Role {
  OWNER = 'owner',
  EDITOR = 'editor',
  VIEWER = 'viewer'
}

enum Permission {
  READ = 'read',
  WRITE = 'write',
  SHARE = 'share',
  DELETE = 'delete'
}

class PermissionMatrix {
  private static permissions: Record<Role, Permission[]> = {
    [Role.OWNER]: [Permission.READ, Permission.WRITE, Permission.SHARE, Permission.DELETE],
    [Role.EDITOR]: [Permission.READ, Permission.WRITE],
    [Role.VIEWER]: [Permission.READ]
  };
}
```

### 6.2 データ保護設計

#### 暗号化
```typescript
interface EncryptionService {
  encrypt(data: string): Promise<string>;
  decrypt(encryptedData: string): Promise<string>;
  hash(password: string): Promise<string>;
  verify(password: string, hash: string): Promise<boolean>;
}
```

## 7. パフォーマンス最適化

### 7.1 キャッシュ戦略

#### Multi-Level Cache
```typescript
interface CacheStrategy {
  // L1: メモリキャッシュ
  memoryCache: MemoryCache;
  
  // L2: Redisキャッシュ
  distributedCache: DistributedCache;
  
  // L3: CDNキャッシュ
  cdnCache: CDNCache;
}

class CacheManager {
  async get<T>(key: string): Promise<T | null> {
    // L1 → L2 → L3 → DB の順で検索
    let value = await this.memoryCache.get(key);
    if (value) return value;
    
    value = await this.distributedCache.get(key);
    if (value) {
      await this.memoryCache.set(key, value);
      return value;
    }
    
    // データベースから取得
    value = await this.database.get(key);
    if (value) {
      await this.distributedCache.set(key, value);
      await this.memoryCache.set(key, value);
    }
    
    return value;
  }
}
```

### 7.2 データベース最適化

#### Read/Write分離
```typescript
interface DatabaseCluster {
  primary: PrimaryDatabase;    // 書き込み専用
  replicas: ReplicaDatabase[]; // 読み取り専用
}

class DatabaseRouter {
  route(operation: DatabaseOperation): Database {
    if (operation.type === 'write') {
      return this.cluster.primary;
    }
    
    // 読み取り負荷分散
    return this.loadBalancer.selectReplica(this.cluster.replicas);
  }
}
```

## 8. 可観測性アーキテクチャ

### 8.1 ログ設計

#### 構造化ログ
```typescript
interface LogEntry {
  timestamp: Date;
  level: LogLevel;
  message: string;
  context: {
    userId?: string;
    whiteboardId?: string;
    action?: string;
    duration?: number;
    error?: Error;
  };
  traceId: string;
}
```

### 8.2 メトリクス設計

#### ビジネスメトリクス
```typescript
interface Metrics {
  // ユーザーメトリクス
  activeUsers: Counter;
  newRegistrations: Counter;
  
  // システムメトリクス  
  apiResponseTime: Histogram;
  websocketConnections: Gauge;
  
  // ビジネスメトリクス
  whiteboardsCreated: Counter;
  collaborationSessions: Histogram;
}
```

## 9. 拡張性設計

### 9.1 モジュラーアーキテクチャ

#### マイクロサービス移行準備
```typescript
// モジュール境界の明確化
interface UserModule {
  authentication: AuthenticationService;
  profile: ProfileService;
  permissions: PermissionService;
}

interface WhiteboardModule {
  creation: WhiteboardCreationService;
  editing: WhiteboardEditingService;
  sharing: WhiteboardSharingService;
}

interface CollaborationModule {
  realtime: RealtimeService;
  notifications: NotificationService;
}
```

### 9.2 プラグインアーキテクチャ

#### 拡張ポイント
```typescript
interface Plugin {
  name: string;
  version: string;
  initialize(context: PluginContext): Promise<void>;
  destroy(): Promise<void>;
}

interface PluginManager {
  register(plugin: Plugin): void;
  unregister(pluginName: string): void;
  executeHook(hookName: string, data: any): Promise<any>;
}
```

---
**作成日**: 2024年7月6日  
**作成者**: [システムアーキテクト名]  
**レビュー者**: [技術リーダー名]  
**承認者**: [CTO名]  
**版数**: 1.0.0