# 単体テスト仕様書

## 1. 概要

### 1.1 目的
個別のコンポーネント・関数・モジュールの動作を検証し、コードの品質と信頼性を確保します。

### 1.2 適用範囲
- **フロントエンド**: Vue.js コンポーネント、Composables、Pinia Store
- **バックエンド**: FastAPI サービス、リポジトリ、ユーティリティ関数
- **共通**: バリデーション関数、ヘルパー関数

### 1.3 テストツール
- **フロントエンド**: Vitest + Vue Test Utils
- **バックエンド**: pytest + pytest-asyncio
- **カバレッジ**: 80%以上を目標

## 2. フロントエンド単体テスト

### 2.1 Vue.js コンポーネントテスト

#### UT_COMP_WHITEBOARD_CANVAS_001: ホワイトボードキャンバス基本レンダリング

**目的**: ホワイトボードキャンバスコンポーネントが正しくレンダリングされることを確認

**前提条件**:
- Vue Test Utils環境が設定済み
- WhiteboardCanvasコンポーネントが実装済み

**テストコード**:
```typescript
import { describe, it, expect } from 'vitest';
import { mount } from '@vue/test-utils';
import { createPinia } from 'pinia';
import WhiteboardCanvas from '@/components/whiteboard/WhiteboardCanvas.vue';

describe('WhiteboardCanvas', () => {
  it('キャンバス要素が正しくレンダリングされる', () => {
    const wrapper = mount(WhiteboardCanvas, {
      global: {
        plugins: [createPinia()],
      },
      props: {
        whiteboardId: 'test-wb-001',
        mode: 'edit'
      }
    });

    expect(wrapper.find('canvas').exists()).toBe(true);
    expect(wrapper.find('.canvas-container').exists()).toBe(true);
    expect(wrapper.find('.canvas-container').classes()).toContain('editable');
  });
});
```

**期待結果**:
- canvas要素が存在する
- canvas-containerクラスが存在する
- editモードの場合、editableクラスが付与される

#### UT_COMP_WHITEBOARD_CANVAS_002: 描画開始イベント

**目的**: マウスダウン時に描画開始イベントが正しく発火されることを確認

**テストコード**:
```typescript
it('描画開始時に正しいイベントが発火される', async () => {
  const wrapper = mount(WhiteboardCanvas, {
    global: { plugins: [createPinia()] },
    props: { whiteboardId: 'test-wb-001', mode: 'edit' }
  });

  const canvas = wrapper.find('canvas');
  await canvas.trigger('mousedown', { 
    clientX: 100, 
    clientY: 100,
    button: 0 
  });

  expect(wrapper.emitted('drawing-start')).toBeTruthy();
  expect(wrapper.emitted('drawing-start')[0]).toEqual([{
    x: 100,
    y: 100,
    tool: 'pen',
    timestamp: expect.any(Number)
  }]);
});
```

**期待結果**:
- drawing-startイベントが発火される
- イベントデータに正しい座標情報が含まれる

#### UT_COMP_TOOLBAR_001: ツールバー選択

**目的**: ツールバーでのツール選択が正しく動作することを確認

**テストコード**:
```typescript
import ToolBar from '@/components/whiteboard/ToolBar.vue';

describe('ToolBar', () => {
  it('ツール選択時に選択状態が更新される', async () => {
    const wrapper = mount(ToolBar, {
      props: { currentTool: 'pen' }
    });

    const rectangleTool = wrapper.find('[data-testid="tool-rectangle"]');
    await rectangleTool.trigger('click');

    expect(wrapper.emitted('tool-changed')).toBeTruthy();
    expect(wrapper.emitted('tool-changed')[0]).toEqual(['rectangle']);
  });

  it('現在選択中のツールにactiveクラスが付与される', () => {
    const wrapper = mount(ToolBar, {
      props: { currentTool: 'circle' }
    });

    const circleTool = wrapper.find('[data-testid="tool-circle"]');
    expect(circleTool.classes()).toContain('active');
  });
});
```

### 2.2 Composables テスト

#### UT_COMP_USE_DRAWING_001: 描画機能基本動作

**目的**: useDrawing composableの基本機能が正しく動作することを確認

**テストコード**:
```typescript
import { describe, it, expect } from 'vitest';
import { useDrawing } from '@/composables/useDrawing';

describe('useDrawing', () => {
  it('描画開始時に状態が正しく更新される', () => {
    const { isDrawing, startDrawing, currentPath } = useDrawing();

    expect(isDrawing.value).toBe(false);
    expect(currentPath.value).toEqual([]);

    startDrawing({ x: 100, y: 100 });

    expect(isDrawing.value).toBe(true);
    expect(currentPath.value).toEqual([{ x: 100, y: 100 }]);
  });

  it('描画終了時に状態がリセットされる', () => {
    const { isDrawing, startDrawing, endDrawing, currentPath } = useDrawing();

    startDrawing({ x: 100, y: 100 });
    endDrawing();

    expect(isDrawing.value).toBe(false);
    expect(currentPath.value).toEqual([]);
  });

  it('ツール変更が正しく機能する', () => {
    const { currentTool, setTool } = useDrawing();

    expect(currentTool.value).toBe('pen');

    setTool('rectangle');
    expect(currentTool.value).toBe('rectangle');
  });
});
```

#### UT_COMP_USE_WEBSOCKET_001: WebSocket接続管理

**目的**: useWebSocket composableの接続管理が正しく動作することを確認

**テストコード**:
```typescript
import { describe, it, expect, vi } from 'vitest';
import { useWebSocket } from '@/composables/useWebSocket';

// WebSocketのモック
const mockWebSocket = {
  send: vi.fn(),
  close: vi.fn(),
  readyState: WebSocket.OPEN
};

global.WebSocket = vi.fn(() => mockWebSocket);

describe('useWebSocket', () => {
  it('WebSocket接続が正しく確立される', () => {
    const { connect, isConnected } = useWebSocket();
    
    connect('ws://localhost:8000/ws/test');
    
    expect(global.WebSocket).toHaveBeenCalledWith('ws://localhost:8000/ws/test');
    expect(isConnected.value).toBe(true);
  });

  it('メッセージ送信が正しく動作する', () => {
    const { connect, sendMessage } = useWebSocket();
    
    connect('ws://localhost:8000/ws/test');
    sendMessage({ type: 'drawing:start', data: { x: 100, y: 100 } });
    
    expect(mockWebSocket.send).toHaveBeenCalledWith(
      JSON.stringify({ type: 'drawing:start', data: { x: 100, y: 100 } })
    );
  });
});
```

### 2.3 Pinia Store テスト

#### UT_STORE_WHITEBOARD_001: ホワイトボードStore基本操作

**目的**: ホワイトボードStoreの基本操作が正しく動作することを確認

**テストコード**:
```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { setActivePinia, createPinia } from 'pinia';
import { useWhiteboardStore } from '@/stores/whiteboard';

describe('WhiteboardStore', () => {
  beforeEach(() => {
    setActivePinia(createPinia());
  });

  it('ホワイトボード作成が正しく機能する', () => {
    const store = useWhiteboardStore();
    
    const whiteboardData = {
      title: 'テストホワイトボード',
      description: 'テスト用の説明'
    };

    store.createWhiteboard(whiteboardData);

    expect(store.whiteboards).toHaveLength(1);
    expect(store.whiteboards[0].title).toBe('テストホワイトボード');
    expect(store.whiteboards[0].id).toBeDefined();
  });

  it('描画要素追加が正しく機能する', () => {
    const store = useWhiteboardStore();
    
    // ホワイトボード作成
    store.createWhiteboard({ title: 'テスト' });
    store.setCurrentWhiteboard(store.whiteboards[0].id);
    
    const element = {
      id: 'element-001',
      type: 'pen',
      position: { x: 100, y: 100 },
      style: { color: '#000000', width: 2 }
    };

    store.addElement(element);

    expect(store.currentElements).toHaveLength(1);
    expect(store.currentElements[0]).toEqual(element);
  });

  it('ホワイトボード削除が正しく機能する', () => {
    const store = useWhiteboardStore();
    
    store.createWhiteboard({ title: 'テスト1' });
    store.createWhiteboard({ title: 'テスト2' });
    
    const firstWhiteboardId = store.whiteboards[0].id;
    store.deleteWhiteboard(firstWhiteboardId);

    expect(store.whiteboards).toHaveLength(1);
    expect(store.whiteboards[0].title).toBe('テスト2');
  });
});
```

## 3. バックエンド単体テスト

### 3.1 サービス層テスト

#### UT_SERVICE_WHITEBOARD_001: ホワイトボードサービス作成

**目的**: ホワイトボードサービスの作成機能が正しく動作することを確認

**テストコード**:
```python
import pytest
from unittest.mock import AsyncMock, MagicMock
from app.services.whiteboard import WhiteboardService
from app.schemas.whiteboard import WhiteboardCreate
from app.models.whiteboard import Whiteboard

class TestWhiteboardService:
    @pytest.fixture
    def mock_repository(self):
        return AsyncMock()
    
    @pytest.fixture
    def service(self, mock_repository):
        return WhiteboardService(mock_repository)
    
    @pytest.mark.asyncio
    async def test_create_whiteboard_success(self, service, mock_repository):
        # Arrange
        whiteboard_data = WhiteboardCreate(
            title="テストホワイトボード",
            description="テスト用の説明"
        )
        
        expected_whiteboard = Whiteboard(
            id="wb-001",
            title="テストホワイトボード",
            description="テスト用の説明",
            owner_id="user-001"
        )
        
        mock_repository.create.return_value = expected_whiteboard
        
        # Act
        result = await service.create_whiteboard(
            whiteboard_data, 
            owner_id="user-001"
        )
        
        # Assert
        assert result.title == "テストホワイトボード"
        assert result.description == "テスト用の説明"
        assert result.owner_id == "user-001"
        mock_repository.create.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_create_whiteboard_invalid_title(self, service):
        # Arrange
        whiteboard_data = WhiteboardCreate(
            title="",  # 空のタイトル
            description="テスト用の説明"
        )
        
        # Act & Assert
        with pytest.raises(ValueError, match="タイトルは必須です"):
            await service.create_whiteboard(whiteboard_data, owner_id="user-001")
```

#### UT_SERVICE_AUTH_001: 認証サービステスト

**目的**: 認証サービスの基本機能が正しく動作することを確認

**テストコード**:
```python
import pytest
from unittest.mock import AsyncMock
from app.services.auth import AuthService
from app.schemas.auth import UserCreate, UserLogin
from app.models.user import User

class TestAuthService:
    @pytest.fixture
    def mock_user_repository(self):
        return AsyncMock()
    
    @pytest.fixture
    def auth_service(self, mock_user_repository):
        return AuthService(mock_user_repository)
    
    @pytest.mark.asyncio
    async def test_register_user_success(self, auth_service, mock_user_repository):
        # Arrange
        user_data = UserCreate(
            email="test@example.com",
            password="ValidPass123!",
            full_name="テストユーザー"
        )
        
        mock_user_repository.get_by_email.return_value = None
        mock_user_repository.create.return_value = User(
            id="user-001",
            email="test@example.com",
            full_name="テストユーザー"
        )
        
        # Act
        result = await auth_service.register_user(user_data)
        
        # Assert
        assert result.email == "test@example.com"
        assert result.full_name == "テストユーザー"
        mock_user_repository.create.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_register_user_duplicate_email(self, auth_service, mock_user_repository):
        # Arrange
        user_data = UserCreate(
            email="existing@example.com",
            password="ValidPass123!",
            full_name="テストユーザー"
        )
        
        mock_user_repository.get_by_email.return_value = User(
            id="existing-user",
            email="existing@example.com"
        )
        
        # Act & Assert
        with pytest.raises(ValueError, match="このメールアドレスは既に使用されています"):
            await auth_service.register_user(user_data)
```

### 3.2 リポジトリ層テスト

#### UT_REPO_WHITEBOARD_001: ホワイトボードリポジトリ基本操作

**目的**: ホワイトボードリポジトリの基本CRUD操作が正しく動作することを確認

**テストコード**:
```python
import pytest
from sqlalchemy.ext.asyncio import AsyncSession
from app.repositories.whiteboard import WhiteboardRepository
from app.models.whiteboard import Whiteboard
from app.models.user import User

class TestWhiteboardRepository:
    @pytest.fixture
    async def db_session(self):
        # テスト用のデータベースセッション
        # pytest-postgresql使用
        pass
    
    @pytest.fixture
    def repository(self, db_session):
        return WhiteboardRepository(db_session)
    
    @pytest.fixture
    async def test_user(self, db_session):
        user = User(
            id="user-001",
            email="test@example.com",
            hashed_password="hashed_password"
        )
        db_session.add(user)
        await db_session.commit()
        return user
    
    @pytest.mark.asyncio
    async def test_create_whiteboard(self, repository, test_user):
        # Arrange
        whiteboard_data = {
            "title": "テストホワイトボード",
            "description": "テスト用の説明",
            "owner_id": test_user.id
        }
        
        # Act
        whiteboard = await repository.create(whiteboard_data)
        
        # Assert
        assert whiteboard.title == "テストホワイトボード"
        assert whiteboard.owner_id == test_user.id
        assert whiteboard.id is not None
    
    @pytest.mark.asyncio
    async def test_get_by_id(self, repository, test_user):
        # Arrange
        whiteboard = await repository.create({
            "title": "テストホワイトボード",
            "owner_id": test_user.id
        })
        
        # Act
        result = await repository.get_by_id(whiteboard.id)
        
        # Assert
        assert result is not None
        assert result.id == whiteboard.id
        assert result.title == "テストホワイトボード"
    
    @pytest.mark.asyncio
    async def test_get_by_owner_id(self, repository, test_user):
        # Arrange
        await repository.create({
            "title": "ホワイトボード1",
            "owner_id": test_user.id
        })
        await repository.create({
            "title": "ホワイトボード2",
            "owner_id": test_user.id
        })
        
        # Act
        whiteboards = await repository.get_by_owner_id(test_user.id)
        
        # Assert
        assert len(whiteboards) == 2
        assert all(wb.owner_id == test_user.id for wb in whiteboards)
```

### 3.3 ユーティリティ関数テスト

#### UT_UTIL_VALIDATION_001: バリデーション関数テスト

**目的**: バリデーション関数が正しく動作することを確認

**テストコード**:
```python
import pytest
from app.utils.validation import (
    validate_email,
    validate_password,
    validate_whiteboard_title
)

class TestValidation:
    def test_validate_email_valid(self):
        # 正常系
        valid_emails = [
            "test@example.com",
            "user.name@domain.co.jp",
            "user+tag@example.org"
        ]
        
        for email in valid_emails:
            assert validate_email(email) is True
    
    def test_validate_email_invalid(self):
        # 異常系
        invalid_emails = [
            "invalid-email",
            "@example.com",
            "user@",
            "",
            None
        ]
        
        for email in invalid_emails:
            assert validate_email(email) is False
    
    def test_validate_password_valid(self):
        # 正常系
        valid_passwords = [
            "ValidPass123!",
            "MyP@ssw0rd",
            "Str0ng#Pass"
        ]
        
        for password in valid_passwords:
            result = validate_password(password)
            assert result["is_valid"] is True
            assert len(result["errors"]) == 0
    
    def test_validate_password_invalid(self):
        # 異常系
        test_cases = [
            ("short", ["パスワードは8文字以上である必要があります"]),
            ("nouppercase", ["大文字を含む必要があります"]),
            ("NOLOWERCASE", ["小文字を含む必要があります"]),
            ("NoNumber!", ["数字を含む必要があります"]),
            ("NoSymbol123", ["記号を含む必要があります"])
        ]
        
        for password, expected_errors in test_cases:
            result = validate_password(password)
            assert result["is_valid"] is False
            for error in expected_errors:
                assert error in result["errors"]
```

## 4. テスト実行とカバレッジ

### 4.1 テスト実行コマンド

#### フロントエンド
```bash
# 全単体テスト実行
npm run test:unit

# カバレッジ付き実行
npm run test:unit -- --coverage

# ウォッチモード
npm run test:unit -- --watch

# 特定ファイルのテスト
npm run test:unit -- src/components/whiteboard/WhiteboardCanvas.test.ts
```

#### バックエンド
```bash
# 全単体テスト実行
pytest tests/unit/

# カバレッジ付き実行
pytest tests/unit/ --cov=app --cov-report=html

# 特定ファイルのテスト
pytest tests/unit/test_whiteboard_service.py

# 並列実行
pytest tests/unit/ -n auto
```

### 4.2 カバレッジ目標

#### フロントエンド目標
- **Components**: 85%以上
- **Composables**: 90%以上
- **Stores**: 90%以上
- **Utils**: 95%以上

#### バックエンド目標
- **Services**: 90%以上
- **Repositories**: 85%以上
- **Utils**: 95%以上
- **Models**: 80%以上

### 4.3 CI/CD統合

```yaml
# GitHub Actions設定例
name: Unit Tests
on: [push, pull_request]

jobs:
  frontend-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      - name: Install dependencies
        run: npm ci
      - name: Run unit tests
        run: npm run test:unit -- --coverage
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        
  backend-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      - name: Install dependencies
        run: pip install -r requirements-dev.txt
      - name: Run unit tests
        run: pytest tests/unit/ --cov=app --cov-report=xml
      - name: Upload coverage
        uses: codecov/codecov-action@v3
```

---
**作成日**: 2024年7月6日  
**作成者**: [QAエンジニア名]  
**レビュー者**: [開発チームリーダー名]  
**承認者**: [テストリーダー名]  
**版数**: 1.0.0